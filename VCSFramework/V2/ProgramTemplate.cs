#nullable enable
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;

namespace VCSFramework.V2
{
    public abstract class ProgramTemplate
    {
        /// <summary>The type that is attributed with <see cref="TemplatedProgramAttribute"/>.</summary>
        protected internal Type ProgramType { get; }

        internal abstract string GeneratedTypeName { get; }

        internal ProgramTemplate(Type programType)
        {
            ProgramType = programType;
        }

        internal abstract string GenerateSourceText();
    }

    public sealed class RawTemplate : ProgramTemplate
    {
        private readonly MethodInfo UserEntryPoint;
        internal override string GeneratedTypeName => "RawTemplatedProgram";

        internal RawTemplate(Type programType) : base(programType)
        {
            // @TODO - Throw if non-void or arity > 0.
            UserEntryPoint = programType.Assembly.EntryPoint ?? throw new ArgumentException($"{programType.FullName} does not contain the entry point.");
        }

        internal override string GenerateSourceText()
        {
            return $@"
// <auto-generated>
// This file was autogenerated as part of the CSharpTo2600 compilation process.
// </auto-generated>

public static class {GeneratedTypeName}
{{
    // The true entry point of the compiled VCS program.
    public static void Main()
    {{
        // A RawTemplate is the lightest template available and has no special features.
        // It's also the default template used if you didn't mark a type with [ProgramTemplate], but have a 'static void Main()' entry point method.

        // Call user entry point. It is up to the user to manually manage everything that's required for a functioning VCS program.
        {$"{UserEntryPoint.DeclaringType!.FullName}.{UserEntryPoint.Name}();"}
    }}
}}";
        }
    }

    public sealed class StandardTemplate : ProgramTemplate
    {
        private readonly ImmutableArray<MethodInfo> VBlanks;
        private readonly MethodInfo Kernel;
        private readonly MethodInfo? Overscan;

        internal override string GeneratedTypeName => "StandardTemplatedProgram";

        public StandardTemplate(Type programType) : base(programType)
        {
            VBlanks = programType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static)
                .Where(m => m.CustomAttributes.Any(a => a.AttributeType == typeof(VBlankAttribute)))
                .ToImmutableArray();
        }

        internal override string GenerateSourceText()
        {
            var prefix = "\t\t\t";
            var vblankCodeBuilder = new StringBuilder();
            if (!VBlanks.Any())
            {
                vblankCodeBuilder.AppendLine($"{prefix}// No user VBlank methods found.");
            }
            else
            {
                foreach (var vblank in VBlanks)
                {
                    vblankCodeBuilder.AppendLine($"{prefix}{ProgramType.FullName}.{vblank.Name}()");
                }
            }

            return $@"
// <auto-generated>
// This file was autogenerated as part of the CSharpTo2600 compilation process.
// </auto-generated>
using static VCSFramework.Registers;

public static class StandardTemplateProgram
{{
    public static void Main()
    {{
        while (true)
        {{
            // VBlank
            VSync = 0b10;
			WSync();
			WSync();
			WSync();
			Tim64T = 43;
			VSync = 0;

{vblankCodeBuilder}

            // @TODO - May want a debug flag that checks if 0 has already passed, to catch overrunning the available time.
            while (InTim != 0) ;

            WSync();
			VBlank = 0;

            // Call kernel
            byte lines = 191;
			while (lines != 0)
			{{
                lines--;
				WSync();
			}}

            // Overscan
            lines = 30;
			while (lines != 0)
			{{
                lines--;
				WSync();
			}}
        }}
    }}
}}";
        }

        public enum KernelType
        {
            Invalid,
            /// <summary>
            /// Method is invoked once for every visible scanline for this program's region.
            /// After the method returns, a WSync() call is performed before calling the method for the next scanline.
            /// </summary>
            EveryScanline,
            // @TODO - Is this even safe to support? Maybe if we could show the user their cycle count. Though in that case, couldn't
            // we just decide for the user whether to emit a WSync() or to eat up the rest of the time for them?
            /// <summary>
            /// Method is invoked once for every visible scanline for this program's region, without adding a WSync() call at the end.
            /// This should be used instead of <see cref="EveryScanline"/> if the user needs the extra time, and is capable of either counting cycles to ensure
            /// that they don't runover to the next scanline.
            /// Cycle counting is inherently fragile when using C# since changes to optimization may produce different timings with the same source code.
            /// </summary>
            EveryScanlineWithoutWSync,
            /// <summary>
            /// Requires another method to have <see cref="EveryOddNumberScanline"/>. Method is invoked for every even-numbered scanline.
            /// </summary>
            EveryEvenNumberScanline,
            EveryOddNumberScanline,
            /// <summary>
            /// Method is invoked once after VBlank. 
            /// User is responsible for manually counting all scanlines and returning control after the appropriate number have been drawn.
            /// </summary>
            Manual,
        }

        // Purposefully nesting these despite being public to make it obvious if you're using the wrong attributes with [ProgramTemplate].
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class VBlankAttribute : Attribute { }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class KernelAttribute : Attribute
        {
            public KernelType KernelType { get; }

            public KernelAttribute(KernelType kernelType)
            {
                KernelType = kernelType;
            }
        }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class KernelScanlineRangeAttribute : Attribute
        {
            public Range Ntsc { get; }
            public Range PalSecam { get; }
            
            public KernelScanlineRangeAttribute(int NtscStart = -1, int NtscEnd = -1, int PalSecamStart = -1, int PalSecamEnd = -1)
            {
                Ntsc = NtscStart..NtscEnd;
                PalSecam = PalSecamStart..PalSecamEnd;
            }
        }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class OverscanAttribute : Attribute { }
    }
}

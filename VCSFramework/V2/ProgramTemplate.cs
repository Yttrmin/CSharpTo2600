#nullable enable
using System;
using System.Reflection;

namespace VCSFramework.V2
{
    public abstract class ProgramTemplate
    {
        /// <summary>The type that is attributed with <see cref="TemplatedProgramAttribute"/>.</summary>
        protected internal Type ProgramType { get; }

        internal abstract string GeneratedTypeName { get; }

        internal ProgramTemplate(Type programType)
        {
            ProgramType = programType;
        }

        internal abstract string GenerateSourceText();
    }

    public sealed class RawTemplate : ProgramTemplate
    {
        private readonly MethodInfo UserEntryPoint;
        internal override string GeneratedTypeName => "RawTemplatedProgram";

        internal RawTemplate(Type programType) : base(programType)
        {
            // @TODO - Throw if non-void or arity > 0.
            UserEntryPoint = programType.Assembly.EntryPoint ?? throw new ArgumentException($"{programType.FullName} does not contain the entry point.");
        }

        internal override string GenerateSourceText()
        {
            return $@"
// <auto-generated>
// This file was autogenerated as part of the CSharpTo2600 compilation process.
// </auto-generated>

public static class {GeneratedTypeName}
{{
    // The true entry point of the compiled VCS program.
    public static void Main()
    {{
        // A RawTemplate is the lightest template available and has no special features.
        // It's also the default template used if you didn't mark a type with [ProgramTemplate], but have a 'static void Main()' entry point method.

        // Call user entry point. It is up to the user to manually manage everything that's required for a functioning VCS program.
        {$"{UserEntryPoint.DeclaringType!.FullName}.{UserEntryPoint.Name}();"}
    }}
}}";
        }
    }

    public sealed class StandardTemplate : ProgramTemplate
    {
        private readonly MethodInfo VBlank;
        private readonly MethodInfo Kernel;
        private readonly MethodInfo Overscan;

        internal override string GeneratedTypeName => "StandardTemplatedProgram";

        public StandardTemplate(Type programType) : base(programType)
        {
            throw new NotImplementedException();
        }

        internal override string GenerateSourceText()
        {
            return $@"
// <auto-generated>
// This file was autogenerated as part of the CSharpTo2600 compilation process.
// </auto-generated>
using static VCSFramework.Registers;

public static class StandardTemplateProgram
{{
    public static void Main()
    {{
        while (true)
        {{
            // VBlank
            VSync = 0b10;
			WSync();
			WSync();
			WSync();
			Tim64T = 43;
			VSync = 0;

            // Call VBlank code

            // @TODO - May want a debug flag that checks if 0 has already passed, to catch overrunning the available time.
            while (InTim != 0) ;

            WSync();
			VBlank = 0;

            // Call kernel

            // Overscan
        }}
    }}
}}";
        }

        public enum KernelType
        {
            Invalid,
            /// <summary>
            /// Method is invoked once for every visible scanline for this program's region.
            /// After the method returns, a WSync() call is performed before calling the method for the next scanline.
            /// </summary>
            EveryScanline,
            /// <summary>
            /// Method is invoked once for every visible scanline for this program's region, without adding a WSync() call at the end.
            /// This should be used instead of <see cref="EveryScanline"/> if the user needs the extra time, and is capable of either counting cycles to ensure
            /// that they don't runover to the next scanline.
            /// Cycle counting is inherently fragile when using C# since changes to optimization may produce different timings with the same source code.
            /// </summary>
            EveryScanlineWithoutWSync,
            EveryOtherScanline,
            /// <summary>
            /// Method is invoked once after VBlank. 
            /// User is responsible for manually counting all scanlines and returning control after the appropriate number have been drawn.
            /// </summary>
            Manual,
        }

        // Purposefully nesting these despite being public to make it obvious if you're using the wrong attributes with [ProgramTemplate].
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class VBlankAttribute : Attribute { }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class KernelAttribute : Attribute
        {
            public KernelType KernelType { get; }

            public KernelAttribute(KernelType kernelType)
            {
                KernelType = kernelType;
            }
        }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
        public sealed class OverscanAttribute : Attribute { }
    }
}
